# 全局唯一id
- id不能自增,数据过于明显
- 受单表数据量的限制
**解决方法:redis全局ID生成器**
ID 组成: 符号位(一位)+时间戳(31位)+序列号(32位)
符号位: 固定为0
时间戳: 31位时间戳
序列号: 32位序列号
# 超卖问题
- CAS法(用于解决ABA问题)
  - 问题:,原来是判定库存是否和原来查询的一致,但在仍然存在库存的情况下,由于另一个线程已经修改了库存,本线程就无法下单
  - 解决方法:只需要判断库存是否大于0即可,如果大于0,则下单,否则返回失败

# 一人一单
- 问题: 由于是多线程,所以会出现一人多单的情况
- 解决方法: 使用悲观锁(synchronized),在查询订单时,对用户id加上锁,防止同一用户的其他线程修改订单
  - 仍然存在问题:在集群部署下,会出现多个节点同时获取锁的情况,导致一人多单的问题
  - 解决方法: 使用redis分布式锁,对用户id加上锁,防止同一用户的其他线程修改订单
    - 仍然存在问题:可能一个线程获取锁后,阻塞了之后,redis锁过期,导致其他线程获取锁,导致一人多单的问题 
    - 解决方法: 
      - 1.在存入锁时存入线程标识  
      - 2.在释放锁时,判断线程标识是否和锁存入的线程标识一致,如果一致,则释放锁,否则不释放锁
        - 仍然存在问题: 在释放锁的时候,可能会出现线程阻塞的情况,导致锁无法释放,此时锁超时释放了,导致其他线程获取锁,导致一人多单的问题 
        - 解决方法: 使用redis的lua的脚本,确保多条命令的原子性

???+ attention
  自动装箱可能会出现空指针异常  
  如果直接返回success,会出现空指针异常  
  因此需要判断是否和true相等,如果相等,则返回success,否则返回false
![装箱拆箱](https://raw.githubusercontent.com/cyprer/photo/main/obsidian/20250316190544668.png)

# 秒杀优化
- 使用redis的lua脚本,确保多条命令的原子性
- 使用redis的set数据结构,完成对库存的管理和一人一单.完成下单业务
- 再将订单数据存入阻塞队列中,使用独立线程异步下单
  
