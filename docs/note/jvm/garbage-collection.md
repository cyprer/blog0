# 垃圾回收机制
## 引用类型
引用类型有四种: 

1. 强引用,被强引用关联的对象不会被回收。
2. 软引用,被软引用关联的对象只有在内存不足时才会被回收。
3. 弱引用,被弱引用关联的对象无论内存是否充足都会被回收。
4. 虚引用,虚引用关联的对象和没有引用关联的对象一样,任何时候都可能被回收。  
   
## 垃圾回收算法
1. 标记-清除算法
**标记:**从 GC Roots 对象开始，遍历整个对象图，标记所有存活的对象。(注意，标记的是存活对象，不是垃圾对象)
**清除:**遍历整个堆内存，回收所有未被标记的（即死亡的）对象所占用的空间。
优点是速度快,缺点是会产生内存碎片

2. 复制算法
    **复制:**将所有对象复制到另一块内存中，然后将原内存空间回收。
    优点是不产生内存碎片,缺点是浪费了一半的内存空间,一定的性能差
2. 标记-整理算法
**标记：**它的第一个阶段与标记-清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。

**整理：**移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。

优点是不会产生内存碎片,缺点就是速度最慢
## 对象存活的判断方法
1. 引用技术法
  引用技术法就是通过判断对象是否被其他对象所引用来判断对象是否存活。
  缺点就是无法解决循环引用问题
2. 可达性分析
这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可达的。
> 但是，并不是说当进行完可达性分析算法后，即可证明某对象可以被GC。对象是否存活，需要两次标记：第一次标记通过可达性分析算法。如果没有GC Roots相连接的引用链，那么将第一次标记如果对象的finalize()方法被重写并且没有执行过，则放在F-Queue队列中等待执行(不一定会执行)，如果一段时间后该对象的finalize()方法被执行且和GC Roots关联，自救成功。如果仍然没有关联，则进行第二次标记，才会对该对象进行回收
可达性分析的一大缺点就是执行时间过长,整个过程是STW的,因此为了解决这个问题,**三色标记法算法**应运而生
3. 三色标记法算法
白色：该对象没有被标记过。在垃圾回收周期开始时，所有对象都是白色。这代表着它们是潜在的垃圾

灰色：该对象已经被标记过了，但该对象的引用的对象还没标记完。

黑色：该对象已经被标记过了，并且他的全部引用对象也都标记完了。
过程:  
三色标记法的标记过程可以分为三个阶段：初始标记（Initial Marking）、并发标记（Concurrent Marking）和重新标记（Remark）。

初始标记： 所有对象初始都是白色。遍历所有的根对象，将根对象和直接引用的对象标记为灰色。在这个阶段中，垃圾回收器只会扫描被直接或者间接引用的对象，而不会扫描整个堆。因此，初始标记阶段的时间比较短。（Stop The World）

并发标记：在这个过程中，垃圾回收器会从灰色对象开始遍历整个对象图，将被引用的对象标记为灰色，并将已经遍历过的对象标记为黑色。并发标记过程中，应用程序线程可能会修改对象图，因此垃圾回收器需要使用写屏障（Write Barrier）技术来保证并发标记的正确性。（不需要STW）

重新标记：重新标记的主要作用是标记在并发标记阶段中被修改的对象以及未被遍历到的对象。这个过程中，垃圾回收器会从灰色对象重新开始遍历对象图，将被引用的对象标记为灰色，并将已经遍历过的对象标记为黑色。（Stop The World）

并发在重新标记阶段结束之后，垃圾回收器会执行清除操作，将未被标记为可达对象的对象进行回收，从而释放内存空间。

## 垃圾收集器
按执行方式分类
1. 串行垃圾收集器:Serial+Serial Old
2. 并行垃圾收集器:Parallel Scavenge+Parallel Old+ParallelNew
3. 并发垃圾收集器:CMS、G1、ZGC
按回收区域分类
1. 新生代垃圾回收器:Parallel Scavenge+ParallelNew
2. 老年代垃圾回收器:Serial Old+Parallel Old+CMS+
3. 整堆回收器:G1+ZGC
### 串行垃圾收集器
- Serial GC 采用的复制算法,收集新生代垃圾,不存在内存碎片,会STW,性能差
- Serial Old GC 采用的标记-整理算法,收集老年代垃圾,存在内存碎片,也会STW,性能差
### 并行垃圾收集器
- Parallel New GC : 其实就是Serial GC的多线程版本使用的也是复制算法
- Parallel Scavenge GC：采用复制算法，仅收集新生代垃圾，不存在内存碎片，多线程并行执行GC，全程STW（STW时长比Serial GC短），性能优于Serial GC

- Parallel Old GC：采用标记-整理算法，仅收集老年代垃圾，不存在内存碎片，多线程并行执行GC，全程STW（STW时长比Serial Old GC短），性能优于Serial Old GC
### 并发垃圾收集器
- CMS:即concurrent mark sweep（并发标记-清除）,显然采用的是标记-清除算法,对于标记使用的是三色标记法,因此收集过程和三色标记法一致
* **G1 (Garbage First)**:
* **内存布局**：彻底取消了传统物理隔断的分代方式，将堆内存划分为多个大小相等的独立区域（**Region**）。Region 可以是 Eden、Survivor、Old 或 Humongous（巨大对象区）。
* **核心算法**：从整体看是基于**标记-整理**，从局部（两个 Region 之间）看是基于**复制算法**。
* **收集过程**：初始标记（STW）、并发标记、最终标记（STW）、**筛选回收（STW）**。
* **三色标记处理**：使用 **SATB（Snapshot-At-The-Beginning）** 技术来解决漏标问题。
* **特点**：支持“可预测的停顿时间模型”，允许用户指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

* **ZGC (Z Garbage Collector)**:
* **设计目标**：在任意堆内存大小下，停顿时间（STW）限制在 **10ms 以内**（JDK 21 之后甚至达到 1ms 级）。
* **核心技术**：
* **染色指针（Colored Pointers）**：直接在 64 位指针的高位中存储元数据（标记信息、重定位信息等），不依赖对象头。
* **读屏障（Read Barrier）**：在程序读取对象引用时触发，用于处理并发移动对象后的指针修正（自愈机制）。


* **核心算法**：基于**标记-整理**。
* **三色标记处理**：由于使用了读屏障和染色指针，它在**并发重定位**阶段表现极其出色。
* **特点**：全并发执行，几乎所有阶段（包括压缩/移动对象）都是并发的；支持极大的堆空间（TB 级别）。



